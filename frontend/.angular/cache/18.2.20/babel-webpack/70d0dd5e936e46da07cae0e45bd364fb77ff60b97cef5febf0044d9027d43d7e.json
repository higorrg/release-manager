{"ast":null,"code":"import { inject, signal, computed } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, of, throwError } from 'rxjs';\nimport { map, catchError, tap } from 'rxjs/operators';\nimport { environment } from '../../../environments/environment';\nimport * as i0 from \"@angular/core\";\nexport let AuthService = /*#__PURE__*/(() => {\n  class AuthService {\n    http = inject(HttpClient);\n    router = inject(Router);\n    // State management with signals\n    currentUserSubject = new BehaviorSubject(null);\n    currentUser$ = this.currentUserSubject.asObservable();\n    // Token management\n    accessToken = signal(null);\n    refreshToken = signal(null);\n    tokenExpiry = signal(null);\n    // Computed values\n    isAuthenticated = computed(() => {\n      const token = this.accessToken();\n      const expiry = this.tokenExpiry();\n      if (!token || !expiry) return false;\n      // Check if token is expired\n      return Date.now() < expiry;\n    });\n    user = computed(() => this.currentUserSubject.value);\n    // Keycloak configuration\n    keycloakConfig = {\n      url: environment.keycloakUrl || 'http://localhost:8080',\n      realm: environment.keycloakRealm || 'release-manager',\n      clientId: environment.keycloakClientId || 'release-manager-app',\n      redirectUri: environment.keycloakRedirectUri || window.location.origin + '/callback'\n    };\n    constructor() {\n      this.loadStoredTokens();\n      this.checkTokenExpiry();\n    }\n    /**\n     * Initiates the SSO login flow with Keycloak\n     */\n    login() {\n      const params = new URLSearchParams({\n        client_id: this.keycloakConfig.clientId,\n        redirect_uri: this.keycloakConfig.redirectUri,\n        response_type: 'code',\n        scope: 'openid profile email',\n        state: this.generateState()\n      });\n      const authUrl = `${this.keycloakConfig.url}/realms/${this.keycloakConfig.realm}/protocol/openid-connect/auth?${params}`;\n      // Store current route to redirect back after login\n      sessionStorage.setItem('redirectUrl', this.router.url);\n      // Redirect to Keycloak login page\n      window.location.href = authUrl;\n    }\n    /**\n     * Handles the callback from Keycloak after login\n     */\n    handleCallback(code, state) {\n      // Verify state to prevent CSRF attacks\n      const storedState = sessionStorage.getItem('oauth_state');\n      if (state !== storedState) {\n        return throwError(() => new Error('Invalid state parameter'));\n      }\n      // Exchange authorization code for tokens\n      return this.exchangeCodeForTokens(code).pipe(tap(tokens => {\n        this.storeTokens(tokens);\n        this.loadUserInfo();\n      }), map(() => true), catchError(error => {\n        console.error('Error during token exchange:', error);\n        return of(false);\n      }));\n    }\n    /**\n     * Exchanges authorization code for access and refresh tokens\n     */\n    exchangeCodeForTokens(code) {\n      const body = new URLSearchParams({\n        grant_type: 'authorization_code',\n        code: code,\n        client_id: this.keycloakConfig.clientId,\n        redirect_uri: this.keycloakConfig.redirectUri\n      });\n      return this.http.post(`${this.keycloakConfig.url}/realms/${this.keycloakConfig.realm}/protocol/openid-connect/token`, body.toString(), {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n    }\n    /**\n     * Refreshes the access token using the refresh token\n     */\n    refreshAccessToken() {\n      const refresh = this.refreshToken();\n      if (!refresh) {\n        return throwError(() => new Error('No refresh token available'));\n      }\n      const body = new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refresh,\n        client_id: this.keycloakConfig.clientId\n      });\n      return this.http.post(`${this.keycloakConfig.url}/realms/${this.keycloakConfig.realm}/protocol/openid-connect/token`, body.toString(), {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      }).pipe(tap(tokens => this.storeTokens(tokens)), catchError(error => {\n        console.error('Error refreshing token:', error);\n        this.logout();\n        return throwError(() => error);\n      }));\n    }\n    /**\n     * Loads user information from Keycloak\n     */\n    loadUserInfo() {\n      const token = this.accessToken();\n      if (!token) return;\n      this.http.get(`${this.keycloakConfig.url}/realms/${this.keycloakConfig.realm}/protocol/openid-connect/userinfo`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      }).subscribe({\n        next: userInfo => {\n          const user = {\n            id: userInfo.sub,\n            username: userInfo.preferred_username || userInfo.sub,\n            email: userInfo.email,\n            name: userInfo.name || userInfo.preferred_username,\n            roles: userInfo.realm_access?.roles || []\n          };\n          this.currentUserSubject.next(user);\n        },\n        error: error => {\n          console.error('Error loading user info:', error);\n        }\n      });\n    }\n    /**\n     * Logs out the user\n     */\n    logout() {\n      const token = this.refreshToken();\n      // Clear stored tokens and user info\n      this.clearTokens();\n      this.currentUserSubject.next(null);\n      // Redirect to Keycloak logout endpoint\n      if (token) {\n        const params = new URLSearchParams({\n          client_id: this.keycloakConfig.clientId,\n          refresh_token: token,\n          post_logout_redirect_uri: window.location.origin\n        });\n        const logoutUrl = `${this.keycloakConfig.url}/realms/${this.keycloakConfig.realm}/protocol/openid-connect/logout?${params}`;\n        window.location.href = logoutUrl;\n      } else {\n        this.router.navigate(['/login']);\n      }\n    }\n    /**\n     * Gets the current access token\n     */\n    getAccessToken() {\n      // Check if token needs refresh\n      const expiry = this.tokenExpiry();\n      if (expiry && Date.now() > expiry - 60000) {\n        // Refresh 1 minute before expiry\n        this.refreshAccessToken().subscribe();\n      }\n      return this.accessToken();\n    }\n    /**\n     * Checks if user has a specific role\n     */\n    hasRole(role) {\n      const user = this.user();\n      return user ? user.roles.includes(role) : false;\n    }\n    /**\n     * Stores tokens in memory and localStorage\n     */\n    storeTokens(tokens) {\n      this.accessToken.set(tokens.access_token);\n      this.refreshToken.set(tokens.refresh_token);\n      const expiry = Date.now() + tokens.expires_in * 1000;\n      this.tokenExpiry.set(expiry);\n      // Store in localStorage for persistence\n      localStorage.setItem('access_token', tokens.access_token);\n      localStorage.setItem('refresh_token', tokens.refresh_token);\n      localStorage.setItem('token_expiry', expiry.toString());\n    }\n    /**\n     * Loads tokens from localStorage on app initialization\n     */\n    loadStoredTokens() {\n      const accessToken = localStorage.getItem('access_token');\n      const refreshToken = localStorage.getItem('refresh_token');\n      const tokenExpiry = localStorage.getItem('token_expiry');\n      if (accessToken && refreshToken && tokenExpiry) {\n        this.accessToken.set(accessToken);\n        this.refreshToken.set(refreshToken);\n        this.tokenExpiry.set(parseInt(tokenExpiry, 10));\n        // Load user info if token is valid\n        if (this.isAuthenticated()) {\n          this.loadUserInfo();\n        } else {\n          // Try to refresh if we have a refresh token\n          this.refreshAccessToken().subscribe();\n        }\n      }\n    }\n    /**\n     * Clears all stored tokens\n     */\n    clearTokens() {\n      this.accessToken.set(null);\n      this.refreshToken.set(null);\n      this.tokenExpiry.set(null);\n      localStorage.removeItem('access_token');\n      localStorage.removeItem('refresh_token');\n      localStorage.removeItem('token_expiry');\n      sessionStorage.removeItem('oauth_state');\n      sessionStorage.removeItem('redirectUrl');\n    }\n    /**\n     * Generates a random state parameter for OAuth\n     */\n    generateState() {\n      const state = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n      sessionStorage.setItem('oauth_state', state);\n      return state;\n    }\n    /**\n     * Periodically checks token expiry\n     */\n    checkTokenExpiry() {\n      setInterval(() => {\n        const expiry = this.tokenExpiry();\n        if (expiry && Date.now() > expiry - 120000) {\n          // 2 minutes before expiry\n          this.refreshAccessToken().subscribe();\n        }\n      }, 60000); // Check every minute\n    }\n    static ɵfac = function AuthService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AuthService)();\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AuthService,\n      factory: AuthService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return AuthService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}